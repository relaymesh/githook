// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: cloud/v1/githooks.proto

package cloudv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	InstallationsService_ListInstallations_FullMethodName   = "/cloud.v1.InstallationsService/ListInstallations"
	InstallationsService_GetInstallationByID_FullMethodName = "/cloud.v1.InstallationsService/GetInstallationByID"
	InstallationsService_UpsertInstallation_FullMethodName  = "/cloud.v1.InstallationsService/UpsertInstallation"
	InstallationsService_DeleteInstallation_FullMethodName  = "/cloud.v1.InstallationsService/DeleteInstallation"
)

// InstallationsServiceClient is the client API for InstallationsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// InstallationsService manages OAuth app installations per tenant.
// An installation represents a GitHub App, GitLab OAuth app, or Bitbucket
// OAuth consumer that has been authorized for a specific account. All RPCs
// are scoped to the calling tenant via the X-Tenant-ID request header.
type InstallationsServiceClient interface {
	// ListInstallations returns all installations visible to the tenant.
	// Filter by provider or state_id (account) to narrow results.
	ListInstallations(ctx context.Context, in *ListInstallationsRequest, opts ...grpc.CallOption) (*ListInstallationsResponse, error)
	// GetInstallationByID fetches a single installation by provider + installation_id.
	GetInstallationByID(ctx context.Context, in *GetInstallationByIDRequest, opts ...grpc.CallOption) (*GetInstallationByIDResponse, error)
	// UpsertInstallation creates or updates an installation record.
	// Used by OAuth callback handlers after a user authorizes the app.
	UpsertInstallation(ctx context.Context, in *UpsertInstallationRequest, opts ...grpc.CallOption) (*UpsertInstallationResponse, error)
	// DeleteInstallation removes an installation and revokes its stored credentials.
	DeleteInstallation(ctx context.Context, in *DeleteInstallationRequest, opts ...grpc.CallOption) (*DeleteInstallationResponse, error)
}

type installationsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInstallationsServiceClient(cc grpc.ClientConnInterface) InstallationsServiceClient {
	return &installationsServiceClient{cc}
}

func (c *installationsServiceClient) ListInstallations(ctx context.Context, in *ListInstallationsRequest, opts ...grpc.CallOption) (*ListInstallationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInstallationsResponse)
	err := c.cc.Invoke(ctx, InstallationsService_ListInstallations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *installationsServiceClient) GetInstallationByID(ctx context.Context, in *GetInstallationByIDRequest, opts ...grpc.CallOption) (*GetInstallationByIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInstallationByIDResponse)
	err := c.cc.Invoke(ctx, InstallationsService_GetInstallationByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *installationsServiceClient) UpsertInstallation(ctx context.Context, in *UpsertInstallationRequest, opts ...grpc.CallOption) (*UpsertInstallationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertInstallationResponse)
	err := c.cc.Invoke(ctx, InstallationsService_UpsertInstallation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *installationsServiceClient) DeleteInstallation(ctx context.Context, in *DeleteInstallationRequest, opts ...grpc.CallOption) (*DeleteInstallationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteInstallationResponse)
	err := c.cc.Invoke(ctx, InstallationsService_DeleteInstallation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstallationsServiceServer is the server API for InstallationsService service.
// All implementations must embed UnimplementedInstallationsServiceServer
// for forward compatibility.
//
// InstallationsService manages OAuth app installations per tenant.
// An installation represents a GitHub App, GitLab OAuth app, or Bitbucket
// OAuth consumer that has been authorized for a specific account. All RPCs
// are scoped to the calling tenant via the X-Tenant-ID request header.
type InstallationsServiceServer interface {
	// ListInstallations returns all installations visible to the tenant.
	// Filter by provider or state_id (account) to narrow results.
	ListInstallations(context.Context, *ListInstallationsRequest) (*ListInstallationsResponse, error)
	// GetInstallationByID fetches a single installation by provider + installation_id.
	GetInstallationByID(context.Context, *GetInstallationByIDRequest) (*GetInstallationByIDResponse, error)
	// UpsertInstallation creates or updates an installation record.
	// Used by OAuth callback handlers after a user authorizes the app.
	UpsertInstallation(context.Context, *UpsertInstallationRequest) (*UpsertInstallationResponse, error)
	// DeleteInstallation removes an installation and revokes its stored credentials.
	DeleteInstallation(context.Context, *DeleteInstallationRequest) (*DeleteInstallationResponse, error)
	mustEmbedUnimplementedInstallationsServiceServer()
}

// UnimplementedInstallationsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInstallationsServiceServer struct{}

func (UnimplementedInstallationsServiceServer) ListInstallations(context.Context, *ListInstallationsRequest) (*ListInstallationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListInstallations not implemented")
}
func (UnimplementedInstallationsServiceServer) GetInstallationByID(context.Context, *GetInstallationByIDRequest) (*GetInstallationByIDResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetInstallationByID not implemented")
}
func (UnimplementedInstallationsServiceServer) UpsertInstallation(context.Context, *UpsertInstallationRequest) (*UpsertInstallationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertInstallation not implemented")
}
func (UnimplementedInstallationsServiceServer) DeleteInstallation(context.Context, *DeleteInstallationRequest) (*DeleteInstallationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteInstallation not implemented")
}
func (UnimplementedInstallationsServiceServer) mustEmbedUnimplementedInstallationsServiceServer() {}
func (UnimplementedInstallationsServiceServer) testEmbeddedByValue()                              {}

// UnsafeInstallationsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstallationsServiceServer will
// result in compilation errors.
type UnsafeInstallationsServiceServer interface {
	mustEmbedUnimplementedInstallationsServiceServer()
}

func RegisterInstallationsServiceServer(s grpc.ServiceRegistrar, srv InstallationsServiceServer) {
	// If the following call panics, it indicates UnimplementedInstallationsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InstallationsService_ServiceDesc, srv)
}

func _InstallationsService_ListInstallations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstallationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstallationsServiceServer).ListInstallations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstallationsService_ListInstallations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstallationsServiceServer).ListInstallations(ctx, req.(*ListInstallationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstallationsService_GetInstallationByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstallationByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstallationsServiceServer).GetInstallationByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstallationsService_GetInstallationByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstallationsServiceServer).GetInstallationByID(ctx, req.(*GetInstallationByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstallationsService_UpsertInstallation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertInstallationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstallationsServiceServer).UpsertInstallation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstallationsService_UpsertInstallation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstallationsServiceServer).UpsertInstallation(ctx, req.(*UpsertInstallationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstallationsService_DeleteInstallation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstallationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstallationsServiceServer).DeleteInstallation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstallationsService_DeleteInstallation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstallationsServiceServer).DeleteInstallation(ctx, req.(*DeleteInstallationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstallationsService_ServiceDesc is the grpc.ServiceDesc for InstallationsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstallationsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.v1.InstallationsService",
	HandlerType: (*InstallationsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListInstallations",
			Handler:    _InstallationsService_ListInstallations_Handler,
		},
		{
			MethodName: "GetInstallationByID",
			Handler:    _InstallationsService_GetInstallationByID_Handler,
		},
		{
			MethodName: "UpsertInstallation",
			Handler:    _InstallationsService_UpsertInstallation_Handler,
		},
		{
			MethodName: "DeleteInstallation",
			Handler:    _InstallationsService_DeleteInstallation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/v1/githooks.proto",
}

const (
	NamespacesService_ListNamespaces_FullMethodName      = "/cloud.v1.NamespacesService/ListNamespaces"
	NamespacesService_SyncNamespaces_FullMethodName      = "/cloud.v1.NamespacesService/SyncNamespaces"
	NamespacesService_GetNamespaceWebhook_FullMethodName = "/cloud.v1.NamespacesService/GetNamespaceWebhook"
	NamespacesService_SetNamespaceWebhook_FullMethodName = "/cloud.v1.NamespacesService/SetNamespaceWebhook"
)

// NamespacesServiceClient is the client API for NamespacesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// NamespacesService manages repository namespaces (repos) discovered via
// installed provider apps. Namespaces are synced from the SCM provider and
// can have webhooks enabled or disabled per repo. All RPCs are tenant-scoped.
type NamespacesServiceClient interface {
	// ListNamespaces returns known repos for the tenant. Filter by provider,
	// owner, repo name, or full_name to narrow results.
	ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error)
	// SyncNamespaces fetches the current repo list from the SCM provider and
	// upserts it into local storage. Returns the refreshed namespace set.
	SyncNamespaces(ctx context.Context, in *SyncNamespacesRequest, opts ...grpc.CallOption) (*SyncNamespacesResponse, error)
	// GetNamespaceWebhook returns whether the webhook is currently registered
	// on the given repo in the SCM provider.
	GetNamespaceWebhook(ctx context.Context, in *GetNamespaceWebhookRequest, opts ...grpc.CallOption) (*GetNamespaceWebhookResponse, error)
	// SetNamespaceWebhook registers or deregisters the githook webhook URL on
	// the given repo. Set enabled=true to register, false to remove.
	SetNamespaceWebhook(ctx context.Context, in *SetNamespaceWebhookRequest, opts ...grpc.CallOption) (*SetNamespaceWebhookResponse, error)
}

type namespacesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNamespacesServiceClient(cc grpc.ClientConnInterface) NamespacesServiceClient {
	return &namespacesServiceClient{cc}
}

func (c *namespacesServiceClient) ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNamespacesResponse)
	err := c.cc.Invoke(ctx, NamespacesService_ListNamespaces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namespacesServiceClient) SyncNamespaces(ctx context.Context, in *SyncNamespacesRequest, opts ...grpc.CallOption) (*SyncNamespacesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncNamespacesResponse)
	err := c.cc.Invoke(ctx, NamespacesService_SyncNamespaces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namespacesServiceClient) GetNamespaceWebhook(ctx context.Context, in *GetNamespaceWebhookRequest, opts ...grpc.CallOption) (*GetNamespaceWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNamespaceWebhookResponse)
	err := c.cc.Invoke(ctx, NamespacesService_GetNamespaceWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namespacesServiceClient) SetNamespaceWebhook(ctx context.Context, in *SetNamespaceWebhookRequest, opts ...grpc.CallOption) (*SetNamespaceWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetNamespaceWebhookResponse)
	err := c.cc.Invoke(ctx, NamespacesService_SetNamespaceWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NamespacesServiceServer is the server API for NamespacesService service.
// All implementations must embed UnimplementedNamespacesServiceServer
// for forward compatibility.
//
// NamespacesService manages repository namespaces (repos) discovered via
// installed provider apps. Namespaces are synced from the SCM provider and
// can have webhooks enabled or disabled per repo. All RPCs are tenant-scoped.
type NamespacesServiceServer interface {
	// ListNamespaces returns known repos for the tenant. Filter by provider,
	// owner, repo name, or full_name to narrow results.
	ListNamespaces(context.Context, *ListNamespacesRequest) (*ListNamespacesResponse, error)
	// SyncNamespaces fetches the current repo list from the SCM provider and
	// upserts it into local storage. Returns the refreshed namespace set.
	SyncNamespaces(context.Context, *SyncNamespacesRequest) (*SyncNamespacesResponse, error)
	// GetNamespaceWebhook returns whether the webhook is currently registered
	// on the given repo in the SCM provider.
	GetNamespaceWebhook(context.Context, *GetNamespaceWebhookRequest) (*GetNamespaceWebhookResponse, error)
	// SetNamespaceWebhook registers or deregisters the githook webhook URL on
	// the given repo. Set enabled=true to register, false to remove.
	SetNamespaceWebhook(context.Context, *SetNamespaceWebhookRequest) (*SetNamespaceWebhookResponse, error)
	mustEmbedUnimplementedNamespacesServiceServer()
}

// UnimplementedNamespacesServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNamespacesServiceServer struct{}

func (UnimplementedNamespacesServiceServer) ListNamespaces(context.Context, *ListNamespacesRequest) (*ListNamespacesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListNamespaces not implemented")
}
func (UnimplementedNamespacesServiceServer) SyncNamespaces(context.Context, *SyncNamespacesRequest) (*SyncNamespacesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncNamespaces not implemented")
}
func (UnimplementedNamespacesServiceServer) GetNamespaceWebhook(context.Context, *GetNamespaceWebhookRequest) (*GetNamespaceWebhookResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNamespaceWebhook not implemented")
}
func (UnimplementedNamespacesServiceServer) SetNamespaceWebhook(context.Context, *SetNamespaceWebhookRequest) (*SetNamespaceWebhookResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetNamespaceWebhook not implemented")
}
func (UnimplementedNamespacesServiceServer) mustEmbedUnimplementedNamespacesServiceServer() {}
func (UnimplementedNamespacesServiceServer) testEmbeddedByValue()                           {}

// UnsafeNamespacesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NamespacesServiceServer will
// result in compilation errors.
type UnsafeNamespacesServiceServer interface {
	mustEmbedUnimplementedNamespacesServiceServer()
}

func RegisterNamespacesServiceServer(s grpc.ServiceRegistrar, srv NamespacesServiceServer) {
	// If the following call panics, it indicates UnimplementedNamespacesServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NamespacesService_ServiceDesc, srv)
}

func _NamespacesService_ListNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespacesServiceServer).ListNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamespacesService_ListNamespaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespacesServiceServer).ListNamespaces(ctx, req.(*ListNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamespacesService_SyncNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespacesServiceServer).SyncNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamespacesService_SyncNamespaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespacesServiceServer).SyncNamespaces(ctx, req.(*SyncNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamespacesService_GetNamespaceWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamespaceWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespacesServiceServer).GetNamespaceWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamespacesService_GetNamespaceWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespacesServiceServer).GetNamespaceWebhook(ctx, req.(*GetNamespaceWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamespacesService_SetNamespaceWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNamespaceWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamespacesServiceServer).SetNamespaceWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamespacesService_SetNamespaceWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamespacesServiceServer).SetNamespaceWebhook(ctx, req.(*SetNamespaceWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NamespacesService_ServiceDesc is the grpc.ServiceDesc for NamespacesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NamespacesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.v1.NamespacesService",
	HandlerType: (*NamespacesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListNamespaces",
			Handler:    _NamespacesService_ListNamespaces_Handler,
		},
		{
			MethodName: "SyncNamespaces",
			Handler:    _NamespacesService_SyncNamespaces_Handler,
		},
		{
			MethodName: "GetNamespaceWebhook",
			Handler:    _NamespacesService_GetNamespaceWebhook_Handler,
		},
		{
			MethodName: "SetNamespaceWebhook",
			Handler:    _NamespacesService_SetNamespaceWebhook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/v1/githooks.proto",
}

const (
	RulesService_MatchRules_FullMethodName = "/cloud.v1.RulesService/MatchRules"
	RulesService_ListRules_FullMethodName  = "/cloud.v1.RulesService/ListRules"
	RulesService_GetRule_FullMethodName    = "/cloud.v1.RulesService/GetRule"
	RulesService_CreateRule_FullMethodName = "/cloud.v1.RulesService/CreateRule"
	RulesService_UpdateRule_FullMethodName = "/cloud.v1.RulesService/UpdateRule"
	RulesService_DeleteRule_FullMethodName = "/cloud.v1.RulesService/DeleteRule"
)

// RulesServiceClient is the client API for RulesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// RulesService manages routing rules that determine which events get published
// to which broker topics. Each rule has a govaluate expression (when) and a
// target topic (emit). Rules are evaluated against every incoming webhook event.
// All RPCs are tenant-scoped via X-Tenant-ID.
type RulesServiceClient interface {
	// MatchRules evaluates a set of rules against an event payload and returns
	// the subset that matched. Useful for testing rules before persisting them.
	MatchRules(ctx context.Context, in *MatchRulesRequest, opts ...grpc.CallOption) (*MatchRulesResponse, error)
	// ListRules returns all rules for the tenant.
	ListRules(ctx context.Context, in *ListRulesRequest, opts ...grpc.CallOption) (*ListRulesResponse, error)
	// GetRule fetches a single rule by its server-assigned ID.
	GetRule(ctx context.Context, in *GetRuleRequest, opts ...grpc.CallOption) (*GetRuleResponse, error)
	// CreateRule persists a new rule. The server assigns an ID and timestamps.
	CreateRule(ctx context.Context, in *CreateRuleRequest, opts ...grpc.CallOption) (*CreateRuleResponse, error)
	// UpdateRule replaces the when/emit/driver_id fields of an existing rule.
	UpdateRule(ctx context.Context, in *UpdateRuleRequest, opts ...grpc.CallOption) (*UpdateRuleResponse, error)
	// DeleteRule removes a rule. In-flight events already matched are unaffected.
	DeleteRule(ctx context.Context, in *DeleteRuleRequest, opts ...grpc.CallOption) (*DeleteRuleResponse, error)
}

type rulesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRulesServiceClient(cc grpc.ClientConnInterface) RulesServiceClient {
	return &rulesServiceClient{cc}
}

func (c *rulesServiceClient) MatchRules(ctx context.Context, in *MatchRulesRequest, opts ...grpc.CallOption) (*MatchRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MatchRulesResponse)
	err := c.cc.Invoke(ctx, RulesService_MatchRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesServiceClient) ListRules(ctx context.Context, in *ListRulesRequest, opts ...grpc.CallOption) (*ListRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRulesResponse)
	err := c.cc.Invoke(ctx, RulesService_ListRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesServiceClient) GetRule(ctx context.Context, in *GetRuleRequest, opts ...grpc.CallOption) (*GetRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRuleResponse)
	err := c.cc.Invoke(ctx, RulesService_GetRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesServiceClient) CreateRule(ctx context.Context, in *CreateRuleRequest, opts ...grpc.CallOption) (*CreateRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRuleResponse)
	err := c.cc.Invoke(ctx, RulesService_CreateRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesServiceClient) UpdateRule(ctx context.Context, in *UpdateRuleRequest, opts ...grpc.CallOption) (*UpdateRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRuleResponse)
	err := c.cc.Invoke(ctx, RulesService_UpdateRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rulesServiceClient) DeleteRule(ctx context.Context, in *DeleteRuleRequest, opts ...grpc.CallOption) (*DeleteRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRuleResponse)
	err := c.cc.Invoke(ctx, RulesService_DeleteRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RulesServiceServer is the server API for RulesService service.
// All implementations must embed UnimplementedRulesServiceServer
// for forward compatibility.
//
// RulesService manages routing rules that determine which events get published
// to which broker topics. Each rule has a govaluate expression (when) and a
// target topic (emit). Rules are evaluated against every incoming webhook event.
// All RPCs are tenant-scoped via X-Tenant-ID.
type RulesServiceServer interface {
	// MatchRules evaluates a set of rules against an event payload and returns
	// the subset that matched. Useful for testing rules before persisting them.
	MatchRules(context.Context, *MatchRulesRequest) (*MatchRulesResponse, error)
	// ListRules returns all rules for the tenant.
	ListRules(context.Context, *ListRulesRequest) (*ListRulesResponse, error)
	// GetRule fetches a single rule by its server-assigned ID.
	GetRule(context.Context, *GetRuleRequest) (*GetRuleResponse, error)
	// CreateRule persists a new rule. The server assigns an ID and timestamps.
	CreateRule(context.Context, *CreateRuleRequest) (*CreateRuleResponse, error)
	// UpdateRule replaces the when/emit/driver_id fields of an existing rule.
	UpdateRule(context.Context, *UpdateRuleRequest) (*UpdateRuleResponse, error)
	// DeleteRule removes a rule. In-flight events already matched are unaffected.
	DeleteRule(context.Context, *DeleteRuleRequest) (*DeleteRuleResponse, error)
	mustEmbedUnimplementedRulesServiceServer()
}

// UnimplementedRulesServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRulesServiceServer struct{}

func (UnimplementedRulesServiceServer) MatchRules(context.Context, *MatchRulesRequest) (*MatchRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MatchRules not implemented")
}
func (UnimplementedRulesServiceServer) ListRules(context.Context, *ListRulesRequest) (*ListRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRules not implemented")
}
func (UnimplementedRulesServiceServer) GetRule(context.Context, *GetRuleRequest) (*GetRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRule not implemented")
}
func (UnimplementedRulesServiceServer) CreateRule(context.Context, *CreateRuleRequest) (*CreateRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRule not implemented")
}
func (UnimplementedRulesServiceServer) UpdateRule(context.Context, *UpdateRuleRequest) (*UpdateRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateRule not implemented")
}
func (UnimplementedRulesServiceServer) DeleteRule(context.Context, *DeleteRuleRequest) (*DeleteRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteRule not implemented")
}
func (UnimplementedRulesServiceServer) mustEmbedUnimplementedRulesServiceServer() {}
func (UnimplementedRulesServiceServer) testEmbeddedByValue()                      {}

// UnsafeRulesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RulesServiceServer will
// result in compilation errors.
type UnsafeRulesServiceServer interface {
	mustEmbedUnimplementedRulesServiceServer()
}

func RegisterRulesServiceServer(s grpc.ServiceRegistrar, srv RulesServiceServer) {
	// If the following call panics, it indicates UnimplementedRulesServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RulesService_ServiceDesc, srv)
}

func _RulesService_MatchRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServiceServer).MatchRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RulesService_MatchRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServiceServer).MatchRules(ctx, req.(*MatchRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RulesService_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServiceServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RulesService_ListRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServiceServer).ListRules(ctx, req.(*ListRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RulesService_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServiceServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RulesService_GetRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServiceServer).GetRule(ctx, req.(*GetRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RulesService_CreateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServiceServer).CreateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RulesService_CreateRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServiceServer).CreateRule(ctx, req.(*CreateRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RulesService_UpdateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServiceServer).UpdateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RulesService_UpdateRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServiceServer).UpdateRule(ctx, req.(*UpdateRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RulesService_DeleteRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RulesServiceServer).DeleteRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RulesService_DeleteRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RulesServiceServer).DeleteRule(ctx, req.(*DeleteRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RulesService_ServiceDesc is the grpc.ServiceDesc for RulesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RulesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.v1.RulesService",
	HandlerType: (*RulesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MatchRules",
			Handler:    _RulesService_MatchRules_Handler,
		},
		{
			MethodName: "ListRules",
			Handler:    _RulesService_ListRules_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _RulesService_GetRule_Handler,
		},
		{
			MethodName: "CreateRule",
			Handler:    _RulesService_CreateRule_Handler,
		},
		{
			MethodName: "UpdateRule",
			Handler:    _RulesService_UpdateRule_Handler,
		},
		{
			MethodName: "DeleteRule",
			Handler:    _RulesService_DeleteRule_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/v1/githooks.proto",
}

const (
	DriversService_ListDrivers_FullMethodName  = "/cloud.v1.DriversService/ListDrivers"
	DriversService_GetDriver_FullMethodName    = "/cloud.v1.DriversService/GetDriver"
	DriversService_UpsertDriver_FullMethodName = "/cloud.v1.DriversService/UpsertDriver"
	DriversService_DeleteDriver_FullMethodName = "/cloud.v1.DriversService/DeleteDriver"
)

// DriversServiceClient is the client API for DriversService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DriversService manages message broker connection configs (AMQP, NATS, Kafka).
// A driver holds the JSON config needed to publish events to a specific broker.
// Rules reference drivers by ID to determine where matched events are sent.
// All RPCs are tenant-scoped via X-Tenant-ID.
type DriversServiceClient interface {
	// ListDrivers returns all driver configs for the tenant.
	ListDrivers(ctx context.Context, in *ListDriversRequest, opts ...grpc.CallOption) (*ListDriversResponse, error)
	// GetDriver fetches a single driver by name.
	GetDriver(ctx context.Context, in *GetDriverRequest, opts ...grpc.CallOption) (*GetDriverResponse, error)
	// UpsertDriver creates or updates a driver config. The name field is the
	// stable identifier; re-submitting with the same name updates in place.
	UpsertDriver(ctx context.Context, in *UpsertDriverRequest, opts ...grpc.CallOption) (*UpsertDriverResponse, error)
	// DeleteDriver removes a driver config. Rules that reference this driver
	// will stop publishing until updated to point at a valid driver.
	DeleteDriver(ctx context.Context, in *DeleteDriverRequest, opts ...grpc.CallOption) (*DeleteDriverResponse, error)
}

type driversServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDriversServiceClient(cc grpc.ClientConnInterface) DriversServiceClient {
	return &driversServiceClient{cc}
}

func (c *driversServiceClient) ListDrivers(ctx context.Context, in *ListDriversRequest, opts ...grpc.CallOption) (*ListDriversResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDriversResponse)
	err := c.cc.Invoke(ctx, DriversService_ListDrivers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driversServiceClient) GetDriver(ctx context.Context, in *GetDriverRequest, opts ...grpc.CallOption) (*GetDriverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDriverResponse)
	err := c.cc.Invoke(ctx, DriversService_GetDriver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driversServiceClient) UpsertDriver(ctx context.Context, in *UpsertDriverRequest, opts ...grpc.CallOption) (*UpsertDriverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertDriverResponse)
	err := c.cc.Invoke(ctx, DriversService_UpsertDriver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *driversServiceClient) DeleteDriver(ctx context.Context, in *DeleteDriverRequest, opts ...grpc.CallOption) (*DeleteDriverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDriverResponse)
	err := c.cc.Invoke(ctx, DriversService_DeleteDriver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DriversServiceServer is the server API for DriversService service.
// All implementations must embed UnimplementedDriversServiceServer
// for forward compatibility.
//
// DriversService manages message broker connection configs (AMQP, NATS, Kafka).
// A driver holds the JSON config needed to publish events to a specific broker.
// Rules reference drivers by ID to determine where matched events are sent.
// All RPCs are tenant-scoped via X-Tenant-ID.
type DriversServiceServer interface {
	// ListDrivers returns all driver configs for the tenant.
	ListDrivers(context.Context, *ListDriversRequest) (*ListDriversResponse, error)
	// GetDriver fetches a single driver by name.
	GetDriver(context.Context, *GetDriverRequest) (*GetDriverResponse, error)
	// UpsertDriver creates or updates a driver config. The name field is the
	// stable identifier; re-submitting with the same name updates in place.
	UpsertDriver(context.Context, *UpsertDriverRequest) (*UpsertDriverResponse, error)
	// DeleteDriver removes a driver config. Rules that reference this driver
	// will stop publishing until updated to point at a valid driver.
	DeleteDriver(context.Context, *DeleteDriverRequest) (*DeleteDriverResponse, error)
	mustEmbedUnimplementedDriversServiceServer()
}

// UnimplementedDriversServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDriversServiceServer struct{}

func (UnimplementedDriversServiceServer) ListDrivers(context.Context, *ListDriversRequest) (*ListDriversResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDrivers not implemented")
}
func (UnimplementedDriversServiceServer) GetDriver(context.Context, *GetDriverRequest) (*GetDriverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDriver not implemented")
}
func (UnimplementedDriversServiceServer) UpsertDriver(context.Context, *UpsertDriverRequest) (*UpsertDriverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertDriver not implemented")
}
func (UnimplementedDriversServiceServer) DeleteDriver(context.Context, *DeleteDriverRequest) (*DeleteDriverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteDriver not implemented")
}
func (UnimplementedDriversServiceServer) mustEmbedUnimplementedDriversServiceServer() {}
func (UnimplementedDriversServiceServer) testEmbeddedByValue()                        {}

// UnsafeDriversServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DriversServiceServer will
// result in compilation errors.
type UnsafeDriversServiceServer interface {
	mustEmbedUnimplementedDriversServiceServer()
}

func RegisterDriversServiceServer(s grpc.ServiceRegistrar, srv DriversServiceServer) {
	// If the following call panics, it indicates UnimplementedDriversServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DriversService_ServiceDesc, srv)
}

func _DriversService_ListDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDriversRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriversServiceServer).ListDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriversService_ListDrivers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriversServiceServer).ListDrivers(ctx, req.(*ListDriversRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriversService_GetDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDriverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriversServiceServer).GetDriver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriversService_GetDriver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriversServiceServer).GetDriver(ctx, req.(*GetDriverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriversService_UpsertDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertDriverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriversServiceServer).UpsertDriver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriversService_UpsertDriver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriversServiceServer).UpsertDriver(ctx, req.(*UpsertDriverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DriversService_DeleteDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDriverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DriversServiceServer).DeleteDriver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DriversService_DeleteDriver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DriversServiceServer).DeleteDriver(ctx, req.(*DeleteDriverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DriversService_ServiceDesc is the grpc.ServiceDesc for DriversService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DriversService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.v1.DriversService",
	HandlerType: (*DriversServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListDrivers",
			Handler:    _DriversService_ListDrivers_Handler,
		},
		{
			MethodName: "GetDriver",
			Handler:    _DriversService_GetDriver_Handler,
		},
		{
			MethodName: "UpsertDriver",
			Handler:    _DriversService_UpsertDriver_Handler,
		},
		{
			MethodName: "DeleteDriver",
			Handler:    _DriversService_DeleteDriver_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/v1/githooks.proto",
}

const (
	ProvidersService_ListProviders_FullMethodName  = "/cloud.v1.ProvidersService/ListProviders"
	ProvidersService_GetProvider_FullMethodName    = "/cloud.v1.ProvidersService/GetProvider"
	ProvidersService_UpsertProvider_FullMethodName = "/cloud.v1.ProvidersService/UpsertProvider"
	ProvidersService_DeleteProvider_FullMethodName = "/cloud.v1.ProvidersService/DeleteProvider"
)

// ProvidersServiceClient is the client API for ProvidersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ProvidersService manages per-tenant SCM provider configurations (GitHub App
// credentials, OAuth client IDs/secrets, webhook secrets). Each provider
// instance is identified by provider name + a server-generated hash so a
// tenant can register multiple instances of the same provider type.
// All RPCs are tenant-scoped via X-Tenant-ID.
type ProvidersServiceClient interface {
	// ListProviders returns all provider configs for the tenant.
	// Filter by provider name (e.g. "github") to narrow results.
	ListProviders(ctx context.Context, in *ListProvidersRequest, opts ...grpc.CallOption) (*ListProvidersResponse, error)
	// GetProvider fetches a single provider config by provider name + hash.
	GetProvider(ctx context.Context, in *GetProviderRequest, opts ...grpc.CallOption) (*GetProviderResponse, error)
	// UpsertProvider creates or updates a provider config. The hash is
	// server-generated on first create; include it on subsequent calls to update.
	UpsertProvider(ctx context.Context, in *UpsertProviderRequest, opts ...grpc.CallOption) (*UpsertProviderResponse, error)
	// DeleteProvider removes a provider config. Existing installations that
	// reference this provider instance will no longer be able to refresh tokens.
	DeleteProvider(ctx context.Context, in *DeleteProviderRequest, opts ...grpc.CallOption) (*DeleteProviderResponse, error)
}

type providersServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProvidersServiceClient(cc grpc.ClientConnInterface) ProvidersServiceClient {
	return &providersServiceClient{cc}
}

func (c *providersServiceClient) ListProviders(ctx context.Context, in *ListProvidersRequest, opts ...grpc.CallOption) (*ListProvidersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProvidersResponse)
	err := c.cc.Invoke(ctx, ProvidersService_ListProviders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providersServiceClient) GetProvider(ctx context.Context, in *GetProviderRequest, opts ...grpc.CallOption) (*GetProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProviderResponse)
	err := c.cc.Invoke(ctx, ProvidersService_GetProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providersServiceClient) UpsertProvider(ctx context.Context, in *UpsertProviderRequest, opts ...grpc.CallOption) (*UpsertProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertProviderResponse)
	err := c.cc.Invoke(ctx, ProvidersService_UpsertProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providersServiceClient) DeleteProvider(ctx context.Context, in *DeleteProviderRequest, opts ...grpc.CallOption) (*DeleteProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProviderResponse)
	err := c.cc.Invoke(ctx, ProvidersService_DeleteProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProvidersServiceServer is the server API for ProvidersService service.
// All implementations must embed UnimplementedProvidersServiceServer
// for forward compatibility.
//
// ProvidersService manages per-tenant SCM provider configurations (GitHub App
// credentials, OAuth client IDs/secrets, webhook secrets). Each provider
// instance is identified by provider name + a server-generated hash so a
// tenant can register multiple instances of the same provider type.
// All RPCs are tenant-scoped via X-Tenant-ID.
type ProvidersServiceServer interface {
	// ListProviders returns all provider configs for the tenant.
	// Filter by provider name (e.g. "github") to narrow results.
	ListProviders(context.Context, *ListProvidersRequest) (*ListProvidersResponse, error)
	// GetProvider fetches a single provider config by provider name + hash.
	GetProvider(context.Context, *GetProviderRequest) (*GetProviderResponse, error)
	// UpsertProvider creates or updates a provider config. The hash is
	// server-generated on first create; include it on subsequent calls to update.
	UpsertProvider(context.Context, *UpsertProviderRequest) (*UpsertProviderResponse, error)
	// DeleteProvider removes a provider config. Existing installations that
	// reference this provider instance will no longer be able to refresh tokens.
	DeleteProvider(context.Context, *DeleteProviderRequest) (*DeleteProviderResponse, error)
	mustEmbedUnimplementedProvidersServiceServer()
}

// UnimplementedProvidersServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProvidersServiceServer struct{}

func (UnimplementedProvidersServiceServer) ListProviders(context.Context, *ListProvidersRequest) (*ListProvidersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProviders not implemented")
}
func (UnimplementedProvidersServiceServer) GetProvider(context.Context, *GetProviderRequest) (*GetProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProvider not implemented")
}
func (UnimplementedProvidersServiceServer) UpsertProvider(context.Context, *UpsertProviderRequest) (*UpsertProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertProvider not implemented")
}
func (UnimplementedProvidersServiceServer) DeleteProvider(context.Context, *DeleteProviderRequest) (*DeleteProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteProvider not implemented")
}
func (UnimplementedProvidersServiceServer) mustEmbedUnimplementedProvidersServiceServer() {}
func (UnimplementedProvidersServiceServer) testEmbeddedByValue()                          {}

// UnsafeProvidersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProvidersServiceServer will
// result in compilation errors.
type UnsafeProvidersServiceServer interface {
	mustEmbedUnimplementedProvidersServiceServer()
}

func RegisterProvidersServiceServer(s grpc.ServiceRegistrar, srv ProvidersServiceServer) {
	// If the following call panics, it indicates UnimplementedProvidersServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProvidersService_ServiceDesc, srv)
}

func _ProvidersService_ListProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProvidersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvidersServiceServer).ListProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProvidersService_ListProviders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvidersServiceServer).ListProviders(ctx, req.(*ListProvidersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvidersService_GetProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvidersServiceServer).GetProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProvidersService_GetProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvidersServiceServer).GetProvider(ctx, req.(*GetProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvidersService_UpsertProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvidersServiceServer).UpsertProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProvidersService_UpsertProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvidersServiceServer).UpsertProvider(ctx, req.(*UpsertProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvidersService_DeleteProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvidersServiceServer).DeleteProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProvidersService_DeleteProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvidersServiceServer).DeleteProvider(ctx, req.(*DeleteProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProvidersService_ServiceDesc is the grpc.ServiceDesc for ProvidersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProvidersService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.v1.ProvidersService",
	HandlerType: (*ProvidersServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProviders",
			Handler:    _ProvidersService_ListProviders_Handler,
		},
		{
			MethodName: "GetProvider",
			Handler:    _ProvidersService_GetProvider_Handler,
		},
		{
			MethodName: "UpsertProvider",
			Handler:    _ProvidersService_UpsertProvider_Handler,
		},
		{
			MethodName: "DeleteProvider",
			Handler:    _ProvidersService_DeleteProvider_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/v1/githooks.proto",
}

const (
	SCMService_GetSCMClient_FullMethodName = "/cloud.v1.SCMService/GetSCMClient"
)

// SCMServiceClient is the client API for SCMService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SCMService provides worker SDKs with short-lived SCM API credentials.
// Workers call GetSCMClient to obtain a provider access token without ever
// storing credentials themselves. The server resolves the token from the
// installation record and refreshes it if expired.
type SCMServiceClient interface {
	// GetSCMClient returns a ready-to-use SCM client credential for the given
	// installation. The access_token may be refreshed server-side before return.
	// Workers should treat the token as short-lived and re-fetch as needed.
	GetSCMClient(ctx context.Context, in *GetSCMClientRequest, opts ...grpc.CallOption) (*GetSCMClientResponse, error)
}

type sCMServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSCMServiceClient(cc grpc.ClientConnInterface) SCMServiceClient {
	return &sCMServiceClient{cc}
}

func (c *sCMServiceClient) GetSCMClient(ctx context.Context, in *GetSCMClientRequest, opts ...grpc.CallOption) (*GetSCMClientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSCMClientResponse)
	err := c.cc.Invoke(ctx, SCMService_GetSCMClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SCMServiceServer is the server API for SCMService service.
// All implementations must embed UnimplementedSCMServiceServer
// for forward compatibility.
//
// SCMService provides worker SDKs with short-lived SCM API credentials.
// Workers call GetSCMClient to obtain a provider access token without ever
// storing credentials themselves. The server resolves the token from the
// installation record and refreshes it if expired.
type SCMServiceServer interface {
	// GetSCMClient returns a ready-to-use SCM client credential for the given
	// installation. The access_token may be refreshed server-side before return.
	// Workers should treat the token as short-lived and re-fetch as needed.
	GetSCMClient(context.Context, *GetSCMClientRequest) (*GetSCMClientResponse, error)
	mustEmbedUnimplementedSCMServiceServer()
}

// UnimplementedSCMServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSCMServiceServer struct{}

func (UnimplementedSCMServiceServer) GetSCMClient(context.Context, *GetSCMClientRequest) (*GetSCMClientResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSCMClient not implemented")
}
func (UnimplementedSCMServiceServer) mustEmbedUnimplementedSCMServiceServer() {}
func (UnimplementedSCMServiceServer) testEmbeddedByValue()                    {}

// UnsafeSCMServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SCMServiceServer will
// result in compilation errors.
type UnsafeSCMServiceServer interface {
	mustEmbedUnimplementedSCMServiceServer()
}

func RegisterSCMServiceServer(s grpc.ServiceRegistrar, srv SCMServiceServer) {
	// If the following call panics, it indicates UnimplementedSCMServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SCMService_ServiceDesc, srv)
}

func _SCMService_GetSCMClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSCMClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCMServiceServer).GetSCMClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCMService_GetSCMClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCMServiceServer).GetSCMClient(ctx, req.(*GetSCMClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SCMService_ServiceDesc is the grpc.ServiceDesc for SCMService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SCMService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.v1.SCMService",
	HandlerType: (*SCMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSCMClient",
			Handler:    _SCMService_GetSCMClient_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/v1/githooks.proto",
}

const (
	EventLogsService_ListEventLogs_FullMethodName         = "/cloud.v1.EventLogsService/ListEventLogs"
	EventLogsService_GetEventLogAnalytics_FullMethodName  = "/cloud.v1.EventLogsService/GetEventLogAnalytics"
	EventLogsService_GetEventLogTimeseries_FullMethodName = "/cloud.v1.EventLogsService/GetEventLogTimeseries"
	EventLogsService_GetEventLogBreakdown_FullMethodName  = "/cloud.v1.EventLogsService/GetEventLogBreakdown"
	EventLogsService_UpdateEventLogStatus_FullMethodName  = "/cloud.v1.EventLogsService/UpdateEventLogStatus"
	EventLogsService_ReplayEventLog_FullMethodName        = "/cloud.v1.EventLogsService/ReplayEventLog"
)

// EventLogsServiceClient is the client API for EventLogsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// EventLogsService provides audit and observability over webhook events.
// Every incoming webhook creates an EventLogRecord regardless of whether it
// matched any rules. Workers update log status after processing. All RPCs
// are tenant-scoped via X-Tenant-ID.
type EventLogsServiceClient interface {
	// ListEventLogs returns paginated event log records. Supports rich filtering
	// by provider, topic, rule, namespace, time range, and match status.
	// Use page_size + page_token for cursor-based pagination (max 200 per page).
	ListEventLogs(ctx context.Context, in *ListEventLogsRequest, opts ...grpc.CallOption) (*ListEventLogsResponse, error)
	// GetEventLogAnalytics returns aggregate counts over a filtered event set.
	// Useful for dashboards showing total events, match rates, and breakdowns.
	GetEventLogAnalytics(ctx context.Context, in *GetEventLogAnalyticsRequest, opts ...grpc.CallOption) (*GetEventLogAnalyticsResponse, error)
	// GetEventLogTimeseries returns event counts bucketed by time interval
	// (hour/day/week). Useful for trend charts. interval is required.
	GetEventLogTimeseries(ctx context.Context, in *GetEventLogTimeseriesRequest, opts ...grpc.CallOption) (*GetEventLogTimeseriesResponse, error)
	// GetEventLogBreakdown returns per-key counts grouped by a chosen dimension
	// (provider, rule, namespace, etc.). Supports sorting and pagination.
	GetEventLogBreakdown(ctx context.Context, in *GetEventLogBreakdownRequest, opts ...grpc.CallOption) (*GetEventLogBreakdownResponse, error)
	// UpdateEventLogStatus lets workers report delivery outcome back to the server.
	// Valid status values: "queued", "delivered", "success", "failed".
	UpdateEventLogStatus(ctx context.Context, in *UpdateEventLogStatusRequest, opts ...grpc.CallOption) (*UpdateEventLogStatusResponse, error)
	ReplayEventLog(ctx context.Context, in *ReplayEventLogRequest, opts ...grpc.CallOption) (*ReplayEventLogResponse, error)
}

type eventLogsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEventLogsServiceClient(cc grpc.ClientConnInterface) EventLogsServiceClient {
	return &eventLogsServiceClient{cc}
}

func (c *eventLogsServiceClient) ListEventLogs(ctx context.Context, in *ListEventLogsRequest, opts ...grpc.CallOption) (*ListEventLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEventLogsResponse)
	err := c.cc.Invoke(ctx, EventLogsService_ListEventLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLogsServiceClient) GetEventLogAnalytics(ctx context.Context, in *GetEventLogAnalyticsRequest, opts ...grpc.CallOption) (*GetEventLogAnalyticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEventLogAnalyticsResponse)
	err := c.cc.Invoke(ctx, EventLogsService_GetEventLogAnalytics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLogsServiceClient) GetEventLogTimeseries(ctx context.Context, in *GetEventLogTimeseriesRequest, opts ...grpc.CallOption) (*GetEventLogTimeseriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEventLogTimeseriesResponse)
	err := c.cc.Invoke(ctx, EventLogsService_GetEventLogTimeseries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLogsServiceClient) GetEventLogBreakdown(ctx context.Context, in *GetEventLogBreakdownRequest, opts ...grpc.CallOption) (*GetEventLogBreakdownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEventLogBreakdownResponse)
	err := c.cc.Invoke(ctx, EventLogsService_GetEventLogBreakdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLogsServiceClient) UpdateEventLogStatus(ctx context.Context, in *UpdateEventLogStatusRequest, opts ...grpc.CallOption) (*UpdateEventLogStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateEventLogStatusResponse)
	err := c.cc.Invoke(ctx, EventLogsService_UpdateEventLogStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLogsServiceClient) ReplayEventLog(ctx context.Context, in *ReplayEventLogRequest, opts ...grpc.CallOption) (*ReplayEventLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplayEventLogResponse)
	err := c.cc.Invoke(ctx, EventLogsService_ReplayEventLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventLogsServiceServer is the server API for EventLogsService service.
// All implementations must embed UnimplementedEventLogsServiceServer
// for forward compatibility.
//
// EventLogsService provides audit and observability over webhook events.
// Every incoming webhook creates an EventLogRecord regardless of whether it
// matched any rules. Workers update log status after processing. All RPCs
// are tenant-scoped via X-Tenant-ID.
type EventLogsServiceServer interface {
	// ListEventLogs returns paginated event log records. Supports rich filtering
	// by provider, topic, rule, namespace, time range, and match status.
	// Use page_size + page_token for cursor-based pagination (max 200 per page).
	ListEventLogs(context.Context, *ListEventLogsRequest) (*ListEventLogsResponse, error)
	// GetEventLogAnalytics returns aggregate counts over a filtered event set.
	// Useful for dashboards showing total events, match rates, and breakdowns.
	GetEventLogAnalytics(context.Context, *GetEventLogAnalyticsRequest) (*GetEventLogAnalyticsResponse, error)
	// GetEventLogTimeseries returns event counts bucketed by time interval
	// (hour/day/week). Useful for trend charts. interval is required.
	GetEventLogTimeseries(context.Context, *GetEventLogTimeseriesRequest) (*GetEventLogTimeseriesResponse, error)
	// GetEventLogBreakdown returns per-key counts grouped by a chosen dimension
	// (provider, rule, namespace, etc.). Supports sorting and pagination.
	GetEventLogBreakdown(context.Context, *GetEventLogBreakdownRequest) (*GetEventLogBreakdownResponse, error)
	// UpdateEventLogStatus lets workers report delivery outcome back to the server.
	// Valid status values: "queued", "delivered", "success", "failed".
	UpdateEventLogStatus(context.Context, *UpdateEventLogStatusRequest) (*UpdateEventLogStatusResponse, error)
	ReplayEventLog(context.Context, *ReplayEventLogRequest) (*ReplayEventLogResponse, error)
	mustEmbedUnimplementedEventLogsServiceServer()
}

// UnimplementedEventLogsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEventLogsServiceServer struct{}

func (UnimplementedEventLogsServiceServer) ListEventLogs(context.Context, *ListEventLogsRequest) (*ListEventLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListEventLogs not implemented")
}
func (UnimplementedEventLogsServiceServer) GetEventLogAnalytics(context.Context, *GetEventLogAnalyticsRequest) (*GetEventLogAnalyticsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEventLogAnalytics not implemented")
}
func (UnimplementedEventLogsServiceServer) GetEventLogTimeseries(context.Context, *GetEventLogTimeseriesRequest) (*GetEventLogTimeseriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEventLogTimeseries not implemented")
}
func (UnimplementedEventLogsServiceServer) GetEventLogBreakdown(context.Context, *GetEventLogBreakdownRequest) (*GetEventLogBreakdownResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEventLogBreakdown not implemented")
}
func (UnimplementedEventLogsServiceServer) UpdateEventLogStatus(context.Context, *UpdateEventLogStatusRequest) (*UpdateEventLogStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateEventLogStatus not implemented")
}
func (UnimplementedEventLogsServiceServer) ReplayEventLog(context.Context, *ReplayEventLogRequest) (*ReplayEventLogResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReplayEventLog not implemented")
}
func (UnimplementedEventLogsServiceServer) mustEmbedUnimplementedEventLogsServiceServer() {}
func (UnimplementedEventLogsServiceServer) testEmbeddedByValue()                          {}

// UnsafeEventLogsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventLogsServiceServer will
// result in compilation errors.
type UnsafeEventLogsServiceServer interface {
	mustEmbedUnimplementedEventLogsServiceServer()
}

func RegisterEventLogsServiceServer(s grpc.ServiceRegistrar, srv EventLogsServiceServer) {
	// If the following call panics, it indicates UnimplementedEventLogsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EventLogsService_ServiceDesc, srv)
}

func _EventLogsService_ListEventLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEventLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLogsServiceServer).ListEventLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventLogsService_ListEventLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLogsServiceServer).ListEventLogs(ctx, req.(*ListEventLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLogsService_GetEventLogAnalytics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventLogAnalyticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLogsServiceServer).GetEventLogAnalytics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventLogsService_GetEventLogAnalytics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLogsServiceServer).GetEventLogAnalytics(ctx, req.(*GetEventLogAnalyticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLogsService_GetEventLogTimeseries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventLogTimeseriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLogsServiceServer).GetEventLogTimeseries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventLogsService_GetEventLogTimeseries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLogsServiceServer).GetEventLogTimeseries(ctx, req.(*GetEventLogTimeseriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLogsService_GetEventLogBreakdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventLogBreakdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLogsServiceServer).GetEventLogBreakdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventLogsService_GetEventLogBreakdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLogsServiceServer).GetEventLogBreakdown(ctx, req.(*GetEventLogBreakdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLogsService_UpdateEventLogStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEventLogStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLogsServiceServer).UpdateEventLogStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventLogsService_UpdateEventLogStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLogsServiceServer).UpdateEventLogStatus(ctx, req.(*UpdateEventLogStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLogsService_ReplayEventLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplayEventLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLogsServiceServer).ReplayEventLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventLogsService_ReplayEventLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLogsServiceServer).ReplayEventLog(ctx, req.(*ReplayEventLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventLogsService_ServiceDesc is the grpc.ServiceDesc for EventLogsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventLogsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cloud.v1.EventLogsService",
	HandlerType: (*EventLogsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListEventLogs",
			Handler:    _EventLogsService_ListEventLogs_Handler,
		},
		{
			MethodName: "GetEventLogAnalytics",
			Handler:    _EventLogsService_GetEventLogAnalytics_Handler,
		},
		{
			MethodName: "GetEventLogTimeseries",
			Handler:    _EventLogsService_GetEventLogTimeseries_Handler,
		},
		{
			MethodName: "GetEventLogBreakdown",
			Handler:    _EventLogsService_GetEventLogBreakdown_Handler,
		},
		{
			MethodName: "UpdateEventLogStatus",
			Handler:    _EventLogsService_UpdateEventLogStatus_Handler,
		},
		{
			MethodName: "ReplayEventLog",
			Handler:    _EventLogsService_ReplayEventLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cloud/v1/githooks.proto",
}
